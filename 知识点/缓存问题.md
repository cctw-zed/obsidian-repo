---
cards-deck: Redis
---
# 缓存穿透 #card
## 概念
当频繁查询缓存和数据库中都不存在的数据时，由于缓存中不存在数据，请求会访问数据库，同时因为数据库也不存在数据，所以也不会再向缓存中写入值。因此，每次请求都会访问数据库，从而给数据库造成很大压力，这种现象叫做缓存穿透。
## 解法
1. [[布隆过滤器]]。提前将存在缓存的key存储到布隆过滤器中，拦截不存在缓存的请求。
2. 缓存空值。访问数据库中不存在的数据时，向缓存中存一个空值，定时过期。但是要注意缓存污染问题。

# 缓存击穿 #card 
## 概念
当频繁查询一个key期间key突然失效时，瞬时会有大量请求访问到数据库，给数据库造成较大压力。
## 解法
1. 加互斥锁。只有获取到锁的请求可以访问数据库并更新缓存。（中间有失败怎么办？）
2. 热点数据不过期，定时主动刷新。

# 缓存雪崩 #card
## 概念
当大量缓存key在同一时刻失效，短时间内有很多请求访问数据库。
## 解法
1. 给失效时间加上一个随机值，防止过期时间集体失效。
2. 加分布式锁。使用Redisson或ZooKeeper等工具实现分布式锁，控制访问数据库的并发量。
3. 使用缓存预热。
4. 使用多级缓存。先查询本地缓存，如果没有再去查询分布式缓存，如果再没有才查询数据库。
5. 限流和熔断。在数据库压力较大的时候，可以采用限流、熔断等策略来减少请求过载，保护数据库免受雪崩的影响。

# 缓存预热 #card 
## 概念
**缓存预热**（Cache Preheating）是指在系统启动或缓存空闲时，主动将一部分热点数据加载到缓存中，确保在用户请求到来之前，这些数据已经存在于缓存中，从而避免首次访问时直接查询数据库，减少数据库的负载。
## 目标
缓存预热的目标是避免系统在高并发场景下因为大量缓存未命中而导致请求直接访问数据库，造成数据库的压力过大。它能够提升系统的响应速度，避免缓存空缺导致的性能瓶颈。
## 实现策略
1. 定时任务。手动编写定时任务，在固定时间刷新缓存。
2. 自动化预热。通过监控访问日志、统计访问频次自动选择数据进行预热。比如对某个key的访问频次超过1k qps时每隔30s进行预热。

# 缓存降级 #card
## 概念
在缓存不可用的情况下，系统自动降级为其他处理方式，确保系统可以继续正常提供服务，减少对数据库的直接访问，防止系统出现雪崩效应或性能瓶颈。
## 常见方式
1. 直接查询数据库。
2. 返回默认值或静态数据。
3. 服务降级。
4. 返回错误提示。
## 实际场景
-  **电商系统**：在电商系统中，商品信息和库存数量通常会被缓存。如果缓存无法访问，系统可能会降级为查询数据库来获取商品信息，或返回一个默认的库存量，避免对数据库的访问压力过大。
- **社交平台**：社交平台上的用户信息和动态可以被缓存。如果缓存不可用，可以返回一个默认的用户动态列表，或通过后台异步更新缓存，避免所有请求都访问数据库。

# 如何保证缓存与数据库双写数据一致？ #card 

